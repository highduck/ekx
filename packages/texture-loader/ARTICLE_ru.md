# Описание проблематики

## Общее Решение

Каждая игра работает с изображениями и должна уметь их загружать. Загрузка изображения:
1. Загрузка Файла. Загрузить байты закодированного изображения с диска или из сети или из любой другой виртуальной файловой системы, как синхронной, так и асинхронной. Так же здесь стоит учесть возможность прямого отображения файла в виртуальную память (mmap)
2. Декодирование изображения. Если изображение представляет собой сырую или сжатую текстур, то мы можем просто сделать отображение этого файла в виртуальную память и декодированные байты у нас в “памяти”
3. Создание статической текстуры и инициализация содержания текстуры (загрузка картинки в текстуру)

**Проблема #1**. В нативной разработке у нас в распоряжении есть масса библиотек различных декодеров, Мы часто включаем код декодеров изображения прямо в билд игры, что значительно увеличивает размер дистрибутива.

**Проблема #2**. Тривиальная загрузка изображений в текстуру обычно делается в основном игровом потоке, что приводит к прерываниям UI. Конечно наиболее простое решение этой проблемы - делегировать этот процесс в фоновый поток и использовать примитивы синхронизации для завершения процесса загрузки. Далее сложность заключается как именно выполнять синхронизацию потока в случае создания и инициализации содержания текстуры.

## Платформы
Как это выглядит для разных платформ?

### Браузер
1. Загрузка файла заведомо асинхронная операция, мы загружаем файл по сети или из хранилища, но эта операция всегда асинхронна в контексте выполнения js в браузере.
2. Декодирование происходит посредством декодера который мы включаем в наш WASM билд. Эта операция синхронна.
   - Мы можем сделать её асинхронной с помощью Worker, но это сильно усложняет архитектуру приложения, тк собирать декодер придется в качестве отдельного модуля. А также синхронизация отдачи результата может быть медленной без SharedArrayBuffer. 
   - Мы можем делегировать процесс декодирования Браузеру, что выглядит наиболее приемлемым здесь вариантом.
3. Создание текстуры здесь это создание и инициализация WebGL текстуры из декодированных байт изображения.

### MacOS, iOS
1. Здесь мы можем загрузить файл из бандла приложения или напрямую из файла, в принципе обычно это решается созданием враппера где происходит вычисление правильного пути и этот путь используется для обычной загрузки файла через fopen или создание его отображение в память через mmap. 
   - Операция сихронная, но может быть делегирована в поток загрузки
2. Синхронный декодер как обычно у нас есть, далее мы в главном или фоновом потоке преобразуем сжатые данные картинки в сырую карту для загрузки в текстуру.
3. Создаем и инициализируем Metal или GLES текстуру из декодированных данных изображения

### Android
1. Для загрузки файла включенного в приложения мы должны использовать AAssetManager API из NDK, далее всё делается как обычно
   - Операция синхронная и может быть выделена в отдельный поток
2. Синхронно декодируем в нативном коде
3. Создаем текстуру в главном потоке

## Задачи

Давайте подумаем, как можно улучшить существующий общий алгоритм загрузки текстуры?

### Только Текстура
Первое на что мы обратим наш взор это результат процесса - Текстура.

Выглядит так, что нам в игре не нужны ни исходные байты картинки, ни декодированные пиксели. Ведь интересует нас только созданная текстура для отрисовки, пиксели из неё мы не получаем и не используем в игровом коде.

Есть задачи, когда нам нужна информация о пикселях, например это:
1. использование на CPU неких масок,
2. узнать является ли пиксель прозрачным для UI системы
3. Генерация игрового содержания основываясь на какие-то растровые шаблоны
4. Проигрывание процедурного музыкального трека из BMP файла
5. Некоторые форматы тайловых карт

Но для таких задач мы можем использовать отдельную сущность которая будет загружаться из простейших форматов изображений, таких как WBMP/TGA/BMP или вообще сырых бинарных несжатых данных.

### Асинхронность загрузки и декодирования
Второй момент это проблема синхронной загрузки. Конечно в идеале мы должны загружать файл и декодировать картинку в фоне, чтобы не блокировать главный поток.

### Стандартные средства системы
Третий момент - есть подозрение что каждая платформа имеет встроенные средства декодирования картинок, и поддерживаемые форматы возможно намного современнее и лучше чем простые PNG файлы. Если эти средства доступны, то зачем нам включать код декодирования изображений в билд игры? Это удобно, достаточно безопасно (если не учесть что вам самим придется патчить эти библиотеки и выпускать обновление игры), работает везде одинаково.

## Требования к новому API
Как правильно поставить задачу и требования к новому загрузчику? Нам нужна Асинхронная загрузка и создание Текстуры. То Есть мы должны взять входные данные и на выходе спустя какое-то время получить созданную инициализированную текстуру или ошибку. Входными данными у нас будут выступать: базовый путь, кол-во картинок для текстуры, пути к этим картинка и специальные флаги подсказки для того чтобы наш загрузчик понимал какую текстуру необходимо создать, например Premultiply Alpha (должны ли быть цвета пред-умножены на Альфа-канал), Cube Map (должна ли это быть куб-текстура). По возможности мы должны использовать системные средства для декодирования картинки. Нам необходимо учесть поддержку форматов картинок и текстур поддерживаемых этой системой.

# Прототипирование














